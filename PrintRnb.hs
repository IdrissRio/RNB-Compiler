{-# LANGUAGE FlexibleInstances, OverlappingInstances #-}
{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}

-- | Pretty-printer for PrintRnb.
--   Generated by the BNF converter.

module PrintRnb where

import AbsRnb
import Data.Char

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 (map ($ "") $ d []) "" where
  rend i ss = case ss of
    "["      :ts -> showChar '[' . rend i ts
    "("      :ts -> showChar '(' . rend i ts
    "{"      :ts -> showChar '{' . new (i+1) . rend (i+1) ts
    "}" : ";":ts -> new (i-1) . space "}" . showChar ';' . new (i-1) . rend (i-1) ts
    "}"      :ts -> new (i-1) . showChar '}' . new (i-1) . rend (i-1) ts
    ";"      :ts -> showChar ';' . new i . rend i ts
    t  : ts@(p:_) | closingOrPunctuation p -> showString t . rend i ts
    t        :ts -> space t . rend i ts
    _            -> id
  new i   = showChar '\n' . replicateS (2*i) (showChar ' ') . dropWhile isSpace
  space t = showString t . (\s -> if null s then "" else ' ':s)

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc
  prtList :: Int -> [a] -> Doc
  prtList i = concatD . map (prt i)

instance Print a => Print [a] where
  prt = prtList

instance Print Char where
  prt _ s = doc (showChar '\'' . mkEsc '\'' s . showChar '\'')
  prtList _ s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q s = case s of
  _ | s == q -> showChar '\\' . showChar s
  '\\'-> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  _ -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print BTry where
  prt _ (BTry (_,i)) = doc (showString i)

instance Print BCatch where
  prt _ (BCatch (_,i)) = doc (showString i)

instance Print BLoop where
  prt _ (BLoop (_,i)) = doc (showString i)

instance Print BCase where
  prt _ (BCase (_,i)) = doc (showString i)

instance Print BAss where
  prt _ (BAss (_,i)) = doc (showString i)

instance Print BPlus where
  prt _ (BPlus (_,i)) = doc (showString i)

instance Print BMinus where
  prt _ (BMinus (_,i)) = doc (showString i)

instance Print BDiv where
  prt _ (BDiv (_,i)) = doc (showString i)

instance Print BMul where
  prt _ (BMul (_,i)) = doc (showString i)

instance Print BUpTo where
  prt _ (BUpTo (_,i)) = doc (showString i)

instance Print BMod where
  prt _ (BMod (_,i)) = doc (showString i)

instance Print BAnd where
  prt _ (BAnd (_,i)) = doc (showString i)

instance Print BOr where
  prt _ (BOr (_,i)) = doc (showString i)

instance Print BNot where
  prt _ (BNot (_,i)) = doc (showString i)

instance Print BLBra where
  prt _ (BLBra (_,i)) = doc (showString i)

instance Print BLe where
  prt _ (BLe (_,i)) = doc (showString i)

instance Print BLeEq where
  prt _ (BLeEq (_,i)) = doc (showString i)

instance Print BGr where
  prt _ (BGr (_,i)) = doc (showString i)

instance Print BGrEq where
  prt _ (BGrEq (_,i)) = doc (showString i)

instance Print BNotEq where
  prt _ (BNotEq (_,i)) = doc (showString i)

instance Print BEq where
  prt _ (BEq (_,i)) = doc (showString i)

instance Print BBool where
  prt _ (BBool (_,i)) = doc (showString i)

instance Print BReturn where
  prt _ (BReturn (_,i)) = doc (showString i)

instance Print BExit where
  prt _ (BExit (_,i)) = doc (showString i)

instance Print BContinue where
  prt _ (BContinue (_,i)) = doc (showString i)

instance Print BExitOn where
  prt _ (BExitOn (_,i)) = doc (showString i)

instance Print BIdent where
  prt _ (BIdent (_,i)) = doc (showString i)

instance Print BInteger where
  prt _ (BInteger (_,i)) = doc (showString i)

instance Print BReal where
  prt _ (BReal (_,i)) = doc (showString i)

instance Print BChar where
  prt _ (BChar (_,i)) = doc (showString i)

instance Print BString where
  prt _ (BString (_,i)) = doc (showString i)

instance Print Program where
  prt i e = case e of
    Start decls -> prPrec i 0 (concatD [prt 0 decls])

instance Print Decl where
  prt i e = case e of
    VarDecl bident type_ -> prPrec i 0 (concatD [prt 0 bident, doc (showString ":"), prt 0 type_, doc (showString ";")])
    VarDef bident type_ bass expr -> prPrec i 0 (concatD [prt 0 bident, doc (showString ":"), prt 0 type_, prt 0 bass, prt 0 expr, doc (showString ";")])
    ConstDef bident type_ bass expr -> prPrec i 0 (concatD [doc (showString "const"), prt 0 bident, doc (showString ":"), prt 0 type_, prt 0 bass, prt 0 expr, doc (showString ";")])
    FuncDef bident1 params bident2 type_ stmts bident3 -> prPrec i 0 (concatD [doc (showString "func"), prt 0 bident1, doc (showString "("), prt 0 params, doc (showString ")"), doc (showString "->"), doc (showString "("), prt 0 bident2, doc (showString ":"), prt 0 type_, doc (showString ")"), doc (showString "is"), prt 0 stmts, doc (showString "end"), prt 0 bident3])
    ProcDef bident1 params stmts bident2 -> prPrec i 0 (concatD [doc (showString "proc"), prt 0 bident1, doc (showString "("), prt 0 params, doc (showString ")"), doc (showString "is"), prt 0 stmts, doc (showString "end"), prt 0 bident2])
  prtList _ [] = concatD []
  prtList _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print [Decl] where
  prt = prtList

instance Print Param where
  prt i e = case e of
    Parameter bident mod type_ -> prPrec i 0 (concatD [prt 0 bident, doc (showString ":"), prt 0 mod, prt 0 type_])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Param] where
  prt = prtList

instance Print Mod where
  prt i e = case e of
    ModRef -> prPrec i 0 (concatD [doc (showString "ref")])
    ModVal -> prPrec i 0 (concatD [])
    ModConst -> prPrec i 0 (concatD [doc (showString "const")])
    ModValRes -> prPrec i 0 (concatD [doc (showString "valres")])

instance Print Expr where
  prt i e = case e of
    ExprVal val -> prPrec i 7 (concatD [prt 0 val])
    ExprArray blbra exprs -> prPrec i 7 (concatD [prt 0 blbra, prt 0 exprs, doc (showString "]")])
    ExprCreate ble type_ bgr expr -> prPrec i 7 (concatD [doc (showString "create"), doc (showString "Array"), prt 0 ble, prt 0 type_, prt 0 bgr, doc (showString "("), prt 0 expr, doc (showString ")")])
    ExprAddress leftexpr -> prPrec i 7 (concatD [doc (showString "\167"), prt 0 leftexpr])
    ExprLeft leftexpr -> prPrec i 7 (concatD [prt 0 leftexpr])
    ExprCall bident exprs -> prPrec i 6 (concatD [prt 0 bident, doc (showString "("), prt 0 exprs, doc (showString ")")])
    ExprBrack expr -> prPrec i 6 (concatD [doc (showString "("), prt 0 expr, doc (showString ")")])
    ExprPostIncr leftexpr -> prPrec i 6 (concatD [prt 0 leftexpr, doc (showString "++")])
    ExprPostDecr leftexpr -> prPrec i 6 (concatD [prt 0 leftexpr, doc (showString "--")])
    ExprPow expr1 bupto expr2 -> prPrec i 5 (concatD [prt 5 expr1, prt 0 bupto, prt 6 expr2])
    ExprMul expr1 bmul expr2 -> prPrec i 3 (concatD [prt 3 expr1, prt 0 bmul, prt 4 expr2])
    ExprMod expr1 bmod expr2 -> prPrec i 3 (concatD [prt 3 expr1, prt 0 bmod, prt 4 expr2])
    ExprDiv expr1 bdiv expr2 -> prPrec i 3 (concatD [prt 3 expr1, prt 0 bdiv, prt 4 expr2])
    ExprSum expr1 bplus expr2 -> prPrec i 2 (concatD [prt 2 expr1, prt 0 bplus, prt 3 expr2])
    ExprMinus expr1 bminus expr2 -> prPrec i 2 (concatD [prt 2 expr1, prt 0 bminus, prt 3 expr2])
    ExprUnaryMinus bminus expr -> prPrec i 3 (concatD [prt 0 bminus, prt 5 expr])
    ExprUnaryPlus bplus expr -> prPrec i 3 (concatD [prt 0 bplus, prt 5 expr])
    ExprAnd expr1 band expr2 -> prPrec i 1 (concatD [prt 1 expr1, prt 0 band, prt 2 expr2])
    ExprOr expr1 bor expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 bor, prt 1 expr2])
    ExprNot bnot expr -> prPrec i 2 (concatD [prt 0 bnot, prt 3 expr])
    ExprRel expr1 rel expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 rel, prt 1 expr2])
    ExprIf expr1 expr2 expr3 -> prPrec i 0 (concatD [prt 0 expr1, doc (showString "if"), prt 0 expr2, doc (showString "else"), prt 0 expr3])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print [Expr] where
  prt = prtList

instance Print Rel where
  prt i e = case e of
    RelLess ble -> prPrec i 0 (concatD [prt 0 ble])
    RelLessEq bleeq -> prPrec i 0 (concatD [prt 0 bleeq])
    RelGreater bgr -> prPrec i 0 (concatD [prt 0 bgr])
    RelGreaterEq bgreq -> prPrec i 0 (concatD [prt 0 bgreq])
    RelNotEq bnoteq -> prPrec i 0 (concatD [prt 0 bnoteq])
    RelEq beq -> prPrec i 0 (concatD [prt 0 beq])

instance Print Stmt where
  prt i e = case e of
    StmtAssign leftexpr bass expr -> prPrec i 0 (concatD [prt 0 leftexpr, prt 0 bass, prt 0 expr, doc (showString ";")])
    StmtIf expr stmts elsestmt -> prPrec i 0 (concatD [doc (showString "if"), prt 0 expr, doc (showString "then"), prt 0 stmts, prt 0 elsestmt, doc (showString "end"), doc (showString "if")])
    StmtLoop bloop1 stmts bloop2 -> prPrec i 0 (concatD [prt 0 bloop1, prt 0 stmts, doc (showString "end"), prt 0 bloop2])
    StmtLoopCmd loopcmd -> prPrec i 0 (concatD [prt 0 loopcmd, doc (showString ";")])
    StmtFor bident btype bass expr1 dir expr2 stmts -> prPrec i 0 (concatD [doc (showString "for"), doc (showString "("), prt 0 bident, doc (showString ":"), prt 0 btype, prt 0 bass, prt 0 expr1, prt 0 dir, prt 0 expr2, doc (showString ")"), prt 0 stmts, doc (showString "end"), doc (showString "for")])
    StmtReturn breturn -> prPrec i 0 (concatD [prt 0 breturn, doc (showString ";")])
    StmtCase bcase1 expr cases bcase2 -> prPrec i 0 (concatD [prt 0 bcase1, prt 0 expr, doc (showString "of"), prt 0 cases, doc (showString "end"), prt 0 bcase2])
    StmtLocal stmts -> prPrec i 0 (concatD [doc (showString "local"), prt 0 stmts, doc (showString "end"), doc (showString "local")])
    StmtDecl decl -> prPrec i 0 (concatD [prt 0 decl])
    StmtExpr expr -> prPrec i 0 (concatD [prt 0 expr, doc (showString ";")])
    StmtTryCatch btry stmts1 bcatch1 stmts2 bcatch2 -> prPrec i 0 (concatD [prt 0 btry, prt 0 stmts1, prt 0 bcatch1, prt 0 stmts2, doc (showString "end"), prt 0 bcatch2])
  prtList _ [] = concatD []
  prtList _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print ElseStmt where
  prt i e = case e of
    StmtElseIf expr stmts elsestmt -> prPrec i 0 (concatD [doc (showString "elseif"), prt 0 expr, doc (showString "then"), prt 0 stmts, prt 0 elsestmt])
    StmtElse stmts -> prPrec i 0 (concatD [doc (showString "else"), prt 0 stmts])
    StmtNoElse -> prPrec i 0 (concatD [])

instance Print [Stmt] where
  prt = prtList

instance Print Dir where
  prt i e = case e of
    FromTo -> prPrec i 0 (concatD [doc (showString "->")])
    DownTo -> prPrec i 0 (concatD [doc (showString "<-")])

instance Print LoopCmd where
  prt i e = case e of
    LoopExitOn bexiton expr -> prPrec i 0 (concatD [prt 0 bexiton, prt 0 expr])
    LoopExit bexit -> prPrec i 0 (concatD [prt 0 bexit])
    LoopContinue bcontinue -> prPrec i 0 (concatD [prt 0 bcontinue])

instance Print Cases where
  prt i e = case e of
    CaseEps -> prPrec i 0 (concatD [])
    CaseDefault stmts -> prPrec i 0 (concatD [doc (showString "else"), prt 0 stmts])
    CaseVal expr stmts cases -> prPrec i 0 (concatD [prt 0 expr, doc (showString "->"), prt 0 stmts, prt 0 cases])

instance Print LeftExpr where
  prt i e = case e of
    LEId bident -> prPrec i 1 (concatD [prt 0 bident])
    LEArray leftexpr dim -> prPrec i 1 (concatD [prt 1 leftexpr, prt 0 dim])
    LEBra leftexpr -> prPrec i 1 (concatD [doc (showString "("), prt 0 leftexpr, doc (showString ")")])
    LEDeref leftexpr -> prPrec i 0 (concatD [doc (showString "\176"), prt 0 leftexpr])
    LEPreIncrem leftexpr -> prPrec i 0 (concatD [doc (showString "++"), prt 0 leftexpr])
    LEPreDecr leftexpr -> prPrec i 0 (concatD [doc (showString "--"), prt 0 leftexpr])

instance Print Dim where
  prt i e = case e of
    DimArray blbra expr -> prPrec i 0 (concatD [prt 0 blbra, prt 0 expr, doc (showString "]")])

instance Print Val where
  prt i e = case e of
    IntVal binteger -> prPrec i 0 (concatD [prt 0 binteger])
    RealVal breal -> prPrec i 0 (concatD [prt 0 breal])
    CharVal bchar -> prPrec i 0 (concatD [prt 0 bchar])
    BoolVal bbool -> prPrec i 0 (concatD [prt 0 bbool])
    StringVal bstring -> prPrec i 0 (concatD [prt 0 bstring])

instance Print Type where
  prt i e = case e of
    BasicType btype -> prPrec i 0 (concatD [prt 0 btype])
    ArrayType ble type_ bgr -> prPrec i 0 (concatD [doc (showString "Array"), prt 0 ble, prt 0 type_, prt 0 bgr])
    ArrayDimType ble type_ bgr expr -> prPrec i 0 (concatD [doc (showString "Array"), prt 0 ble, prt 0 type_, prt 0 bgr, doc (showString "("), prt 0 expr, doc (showString ")")])
    PointerType type_ -> prPrec i 0 (concatD [doc (showString "\176"), prt 0 type_])

instance Print BType where
  prt i e = case e of
    TypeInt -> prPrec i 0 (concatD [doc (showString "int")])
    TypeReal -> prPrec i 0 (concatD [doc (showString "real")])
    TypeChar -> prPrec i 0 (concatD [doc (showString "char")])
    TypeBool -> prPrec i 0 (concatD [doc (showString "bool")])
    TypeString -> prPrec i 0 (concatD [doc (showString "string")])


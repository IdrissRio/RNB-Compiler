-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParRnb where
import AbsRnb
import LexRnb
import ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '++' { PT _ (TS _ 3) }
  ',' { PT _ (TS _ 4) }
  '--' { PT _ (TS _ 5) }
  '->' { PT _ (TS _ 6) }
  ':' { PT _ (TS _ 7) }
  ';' { PT _ (TS _ 8) }
  '<-' { PT _ (TS _ 9) }
  'Array' { PT _ (TS _ 10) }
  ']' { PT _ (TS _ 11) }
  'bool' { PT _ (TS _ 12) }
  'char' { PT _ (TS _ 13) }
  'const' { PT _ (TS _ 14) }
  'create' { PT _ (TS _ 15) }
  'else' { PT _ (TS _ 16) }
  'elseif' { PT _ (TS _ 17) }
  'end' { PT _ (TS _ 18) }
  'for' { PT _ (TS _ 19) }
  'func' { PT _ (TS _ 20) }
  'if' { PT _ (TS _ 21) }
  'int' { PT _ (TS _ 22) }
  'is' { PT _ (TS _ 23) }
  'local' { PT _ (TS _ 24) }
  'of' { PT _ (TS _ 25) }
  'proc' { PT _ (TS _ 26) }
  'real' { PT _ (TS _ 27) }
  'ref' { PT _ (TS _ 28) }
  'string' { PT _ (TS _ 29) }
  'then' { PT _ (TS _ 30) }
  'valres' { PT _ (TS _ 31) }
  '§' { PT _ (TS _ 32) }
  '°' { PT _ (TS _ 33) }

L_BTry { PT _ (T_BTry _) }
L_BCatch { PT _ (T_BCatch _) }
L_BLoop { PT _ (T_BLoop _) }
L_BCase { PT _ (T_BCase _) }
L_BAss { PT _ (T_BAss _) }
L_BPlus { PT _ (T_BPlus _) }
L_BMinus { PT _ (T_BMinus _) }
L_BDiv { PT _ (T_BDiv _) }
L_BMul { PT _ (T_BMul _) }
L_BUpTo { PT _ (T_BUpTo _) }
L_BMod { PT _ (T_BMod _) }
L_BAnd { PT _ (T_BAnd _) }
L_BOr { PT _ (T_BOr _) }
L_BNot { PT _ (T_BNot _) }
L_BLBra { PT _ (T_BLBra _) }
L_BLe { PT _ (T_BLe _) }
L_BLeEq { PT _ (T_BLeEq _) }
L_BGr { PT _ (T_BGr _) }
L_BGrEq { PT _ (T_BGrEq _) }
L_BNotEq { PT _ (T_BNotEq _) }
L_BEq { PT _ (T_BEq _) }
L_BBool { PT _ (T_BBool _) }
L_BReturn { PT _ (T_BReturn _) }
L_BExit { PT _ (T_BExit _) }
L_BContinue { PT _ (T_BContinue _) }
L_BExitOn { PT _ (T_BExitOn _) }
L_BIdent { PT _ (T_BIdent _) }
L_BInteger { PT _ (T_BInteger _) }
L_BReal { PT _ (T_BReal _) }
L_BChar { PT _ (T_BChar _) }
L_BString { PT _ (T_BString _) }


%%

BTry    :: { BTry} : L_BTry { BTry (mkPosToken $1)}
BCatch    :: { BCatch} : L_BCatch { BCatch (mkPosToken $1)}
BLoop    :: { BLoop} : L_BLoop { BLoop (mkPosToken $1)}
BCase    :: { BCase} : L_BCase { BCase (mkPosToken $1)}
BAss    :: { BAss} : L_BAss { BAss (mkPosToken $1)}
BPlus    :: { BPlus} : L_BPlus { BPlus (mkPosToken $1)}
BMinus    :: { BMinus} : L_BMinus { BMinus (mkPosToken $1)}
BDiv    :: { BDiv} : L_BDiv { BDiv (mkPosToken $1)}
BMul    :: { BMul} : L_BMul { BMul (mkPosToken $1)}
BUpTo    :: { BUpTo} : L_BUpTo { BUpTo (mkPosToken $1)}
BMod    :: { BMod} : L_BMod { BMod (mkPosToken $1)}
BAnd    :: { BAnd} : L_BAnd { BAnd (mkPosToken $1)}
BOr    :: { BOr} : L_BOr { BOr (mkPosToken $1)}
BNot    :: { BNot} : L_BNot { BNot (mkPosToken $1)}
BLBra    :: { BLBra} : L_BLBra { BLBra (mkPosToken $1)}
BLe    :: { BLe} : L_BLe { BLe (mkPosToken $1)}
BLeEq    :: { BLeEq} : L_BLeEq { BLeEq (mkPosToken $1)}
BGr    :: { BGr} : L_BGr { BGr (mkPosToken $1)}
BGrEq    :: { BGrEq} : L_BGrEq { BGrEq (mkPosToken $1)}
BNotEq    :: { BNotEq} : L_BNotEq { BNotEq (mkPosToken $1)}
BEq    :: { BEq} : L_BEq { BEq (mkPosToken $1)}
BBool    :: { BBool} : L_BBool { BBool (mkPosToken $1)}
BReturn    :: { BReturn} : L_BReturn { BReturn (mkPosToken $1)}
BExit    :: { BExit} : L_BExit { BExit (mkPosToken $1)}
BContinue    :: { BContinue} : L_BContinue { BContinue (mkPosToken $1)}
BExitOn    :: { BExitOn} : L_BExitOn { BExitOn (mkPosToken $1)}
BIdent    :: { BIdent} : L_BIdent { BIdent (mkPosToken $1)}
BInteger    :: { BInteger} : L_BInteger { BInteger (mkPosToken $1)}
BReal    :: { BReal} : L_BReal { BReal (mkPosToken $1)}
BChar    :: { BChar} : L_BChar { BChar (mkPosToken $1)}
BString    :: { BString} : L_BString { BString (mkPosToken $1)}

Program :: { Program }
Program : ListDecl { AbsRnb.Start (reverse $1) }
Decl :: { Decl }
Decl : BIdent ':' Type ';' { AbsRnb.VarDecl $1 $3 }
     | BIdent ':' Type BAss Expr ';' { AbsRnb.VarDef $1 $3 $4 $5 }
     | 'const' BIdent ':' Type BAss Expr ';' { AbsRnb.ConstDef $2 $4 $5 $6 }
     | 'func' BIdent '(' ListParam ')' '->' '(' BIdent ':' Type ')' 'is' ListStmt 'end' BIdent { AbsRnb.FuncDef $2 $4 $8 $10 (reverse $13) $15 }
     | 'proc' BIdent '(' ListParam ')' 'is' ListStmt 'end' BIdent { AbsRnb.ProcDef $2 $4 (reverse $7) $9 }
ListDecl :: { [Decl] }
ListDecl : {- empty -} { [] } | ListDecl Decl { flip (:) $1 $2 }
Param :: { Param }
Param : BIdent ':' Mod Type { AbsRnb.Parameter $1 $3 $4 }
ListParam :: { [Param] }
ListParam : {- empty -} { [] }
          | Param { (:[]) $1 }
          | Param ',' ListParam { (:) $1 $3 }
Mod :: { Mod }
Mod : 'ref' { AbsRnb.ModRef }
    | {- empty -} { AbsRnb.ModVal }
    | 'const' { AbsRnb.ModConst }
    | 'valres' { AbsRnb.ModValRes }
Expr7 :: { Expr }
Expr7 : Val { AbsRnb.ExprVal $1 }
      | BLBra ListExpr ']' { AbsRnb.ExprArray $1 $2 }
      | 'create' 'Array' BLe Type BGr '(' Expr ')' { AbsRnb.ExprCreate $3 $4 $5 $7 }
      | '§' LeftExpr { AbsRnb.ExprAddress $2 }
      | LeftExpr { AbsRnb.ExprLeft $1 }
Expr6 :: { Expr }
Expr6 : BIdent '(' ListExpr ')' { AbsRnb.ExprCall $1 $3 }
      | '(' Expr ')' { AbsRnb.ExprBrack $2 }
      | LeftExpr '++' { AbsRnb.ExprPostIncr $1 }
      | LeftExpr '--' { AbsRnb.ExprPostDecr $1 }
      | Expr7 { $1 }
Expr5 :: { Expr }
Expr5 : Expr5 BUpTo Expr6 { AbsRnb.ExprPow $1 $2 $3 }
      | Expr6 { $1 }
Expr3 :: { Expr }
Expr3 : Expr3 BMul Expr4 { AbsRnb.ExprMul $1 $2 $3 }
      | Expr3 BMod Expr4 { AbsRnb.ExprMod $1 $2 $3 }
      | Expr3 BDiv Expr4 { AbsRnb.ExprDiv $1 $2 $3 }
      | BMinus Expr5 { AbsRnb.ExprUnaryMinus $1 $2 }
      | BPlus Expr5 { AbsRnb.ExprUnaryPlus $1 $2 }
      | Expr4 { $1 }
Expr2 :: { Expr }
Expr2 : Expr2 BPlus Expr3 { AbsRnb.ExprSum $1 $2 $3 }
      | Expr2 BMinus Expr3 { AbsRnb.ExprMinus $1 $2 $3 }
      | BNot Expr3 { AbsRnb.ExprNot $1 $2 }
      | Expr3 { $1 }
Expr1 :: { Expr }
Expr1 : Expr1 BAnd Expr2 { AbsRnb.ExprAnd $1 $2 $3 } | Expr2 { $1 }
Expr0 :: { Expr }
Expr0 : Expr0 BOr Expr1 { AbsRnb.ExprOr $1 $2 $3 }
      | Expr0 Rel Expr1 { AbsRnb.ExprRel $1 $2 $3 }
      | Expr1 { $1 }
Expr :: { Expr }
Expr : Expr0 'if' Expr0 'else' Expr0 { AbsRnb.ExprIf $1 $3 $5 }
     | Expr0 { $1 }
Expr4 :: { Expr }
Expr4 : Expr5 { $1 }
ListExpr :: { [Expr] }
ListExpr : {- empty -} { [] }
         | Expr { (:[]) $1 }
         | Expr ',' ListExpr { (:) $1 $3 }
Rel :: { Rel }
Rel : BLe { AbsRnb.RelLess $1 }
    | BLeEq { AbsRnb.RelLessEq $1 }
    | BGr { AbsRnb.RelGreater $1 }
    | BGrEq { AbsRnb.RelGreaterEq $1 }
    | BNotEq { AbsRnb.RelNotEq $1 }
    | BEq { AbsRnb.RelEq $1 }
Stmt :: { Stmt }
Stmt : LeftExpr BAss Expr ';' { AbsRnb.StmtAssign $1 $2 $3 }
     | 'if' Expr 'then' ListStmt ElseStmt 'end' 'if' { AbsRnb.StmtIf $2 (reverse $4) $5 }
     | BLoop ListStmt 'end' BLoop { AbsRnb.StmtLoop $1 (reverse $2) $4 }
     | LoopCmd ';' { AbsRnb.StmtLoopCmd $1 }
     | 'for' '(' BIdent ':' BType BAss Expr Dir Expr ')' ListStmt 'end' 'for' { AbsRnb.StmtFor $3 $5 $6 $7 $8 $9 (reverse $11) }
     | BReturn ';' { AbsRnb.StmtReturn $1 }
     | BCase Expr 'of' Cases 'end' BCase { AbsRnb.StmtCase $1 $2 $4 $6 }
     | 'local' ListStmt 'end' 'local' { AbsRnb.StmtLocal (reverse $2) }
     | Decl { AbsRnb.StmtDecl $1 }
     | Expr ';' { AbsRnb.StmtExpr $1 }
     | BTry ListStmt BCatch ListStmt 'end' BCatch { AbsRnb.StmtTryCatch $1 (reverse $2) $3 (reverse $4) $6 }
ElseStmt :: { ElseStmt }
ElseStmt : 'elseif' Expr 'then' ListStmt ElseStmt { AbsRnb.StmtElseIf $2 (reverse $4) $5 }
         | 'else' ListStmt { AbsRnb.StmtElse (reverse $2) }
         | {- empty -} { AbsRnb.StmtNoElse }
ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] } | ListStmt Stmt { flip (:) $1 $2 }
Dir :: { Dir }
Dir : '->' { AbsRnb.FromTo } | '<-' { AbsRnb.DownTo }
LoopCmd :: { LoopCmd }
LoopCmd : BExitOn Expr { AbsRnb.LoopExitOn $1 $2 }
        | BExit { AbsRnb.LoopExit $1 }
        | BContinue { AbsRnb.LoopContinue $1 }
Cases :: { Cases }
Cases : {- empty -} { AbsRnb.CaseEps }
      | 'else' ListStmt { AbsRnb.CaseDefault (reverse $2) }
      | Expr '->' ListStmt Cases { AbsRnb.CaseVal $1 (reverse $3) $4 }
LeftExpr1 :: { LeftExpr }
LeftExpr1 : BIdent { AbsRnb.LEId $1 }
          | LeftExpr1 Dim { AbsRnb.LEArray $1 $2 }
          | '(' LeftExpr ')' { AbsRnb.LEBra $2 }
LeftExpr :: { LeftExpr }
LeftExpr : '°' LeftExpr { AbsRnb.LEDeref $2 }
         | '++' LeftExpr { AbsRnb.LEPreIncrem $2 }
         | '--' LeftExpr { AbsRnb.LEPreDecr $2 }
         | LeftExpr1 { $1 }
Dim :: { Dim }
Dim : BLBra Expr ']' { AbsRnb.DimArray $1 $2 }
Val :: { Val }
Val : BInteger { AbsRnb.IntVal $1 }
    | BReal { AbsRnb.RealVal $1 }
    | BChar { AbsRnb.CharVal $1 }
    | BBool { AbsRnb.BoolVal $1 }
    | BString { AbsRnb.StringVal $1 }
Type :: { Type }
Type : BType { AbsRnb.BasicType $1 }
     | 'Array' BLe Type BGr { AbsRnb.ArrayType $2 $3 $4 }
     | 'Array' BLe Type BGr '(' Expr ')' { AbsRnb.ArrayDimType $2 $3 $4 $6 }
     | '°' Type { AbsRnb.PointerType $2 }
BType :: { BType }
BType : 'int' { AbsRnb.TypeInt }
      | 'real' { AbsRnb.TypeReal }
      | 'char' { AbsRnb.TypeChar }
      | 'bool' { AbsRnb.TypeBool }
      | 'string' { AbsRnb.TypeString }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

